[
    {
        "BriefDescription": "Cycles when divide unit is busy executing divide or square root operations.",
        "CounterMask": "1",
        "EventCode": "0xb0",
        "EventName": "ARITH.DIV_ACTIVE",
        "PublicDescription": "Counts cycles when divide unit is busy executing divide or square root operations. Accounts for integer and floating-point operations.",
        "SampleAfterValue": "1000003",
        "UMask": "0x9",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of cycles when any of the dividers are active.",
        "CounterMask": "1",
        "EventCode": "0xcd",
        "EventName": "ARITH.DIV_ACTIVE",
        "SampleAfterValue": "1000003",
        "UMask": "0x3",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of active floating point and integer dividers per cycle.",
        "EventCode": "0xcd",
        "EventName": "ARITH.DIV_OCCUPANCY",
        "SampleAfterValue": "1000003",
        "UMask": "0x3",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of active floating point and integer divider uops executed per cycle.",
        "EventCode": "0xcd",
        "EventName": "ARITH.DIV_UOPS",
        "SampleAfterValue": "1000003",
        "UMask": "0xc",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "This event counts the number of uops executed corresponding to arithmetic FP instructions with at least 1 architecturally masked-out element.",
        "EventCode": "0xb0",
        "EventName": "ARITH.FP_MASKED_OP",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles when integer divide unit is busy executing divide or square root operations.",
        "CounterMask": "1",
        "EventCode": "0xb0",
        "EventName": "ARITH.IDIV_ACTIVE",
        "PublicDescription": "Counts cycles when divide unit is busy executing divide or square root operations. Accounts for integer operations only.",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of cycles when any of the integer dividers are active.",
        "CounterMask": "1",
        "EventCode": "0xcd",
        "EventName": "ARITH.IDIV_ACTIVE",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "This event counts the number of integer divide instructions executed this cycle.",
        "EventCode": "0xb0",
        "EventName": "ARITH.IDIV_INST",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Count number of active int dividers per cycle",
        "EventCode": "0xcd",
        "EventName": "ARITH.IDIV_OCCUPANCY",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Count the number of int divider uops executed per cycle",
        "EventCode": "0xcd",
        "EventName": "ARITH.IDIV_UOPS",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "This event counts the number of integer multiplication executed this cycle.",
        "EventCode": "0xb0",
        "EventName": "ARITH.IMUL",
        "SampleAfterValue": "1000003",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of occurrences where a microcode assist is invoked by hardware.",
        "EventCode": "0xc1",
        "EventName": "ASSISTS.ANY",
        "PublicDescription": "Counts the number of occurrences where a microcode assist is invoked by hardware. Examples include AD (page Access Dirty), FP and AVX related assists.",
        "SampleAfterValue": "100003",
        "UMask": "0x1f",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "All branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.ALL_BRANCHES",
        "PEBS": "1",
        "PublicDescription": "Counts all branch instructions retired.",
        "SampleAfterValue": "400009",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the total number of branch instructions retired for all branch types.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.ALL_BRANCHES",
        "PEBS": "1",
        "PublicDescription": "Counts the total number of instructions in which the instruction pointer (IP) of the processor is resteered due to a branch instruction and the branch instruction successfully retires.  All branch type instructions are accounted for.",
        "SampleAfterValue": "200003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of taken branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.ALL_NEAR_TAKEN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xc0",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Conditional branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND",
        "PEBS": "1",
        "PublicDescription": "Counts conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x111",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts retired JCC (Jump on Conditional Code) branch instructions retired includes both taken and not taken branches",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x7e",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Not taken branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_NTAKEN",
        "PEBS": "1",
        "PublicDescription": "Counts not taken branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of not taken JCC branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_NTAKEN",
        "SampleAfterValue": "1000003",
        "UMask": "0x7f",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Taken conditional branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_TAKEN",
        "PEBS": "1",
        "PublicDescription": "Counts taken conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x101",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of taken JCC branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_TAKEN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xfe",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Taken backward conditional branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_TAKEN_BWD",
        "PEBS": "1",
        "PublicDescription": "Counts taken backward conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Taken forward conditional branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_TAKEN_FWD",
        "PEBS": "1",
        "PublicDescription": "Counts taken forward conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Far branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.FAR_BRANCH",
        "PEBS": "1",
        "PublicDescription": "Counts far branch instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of far branch instructions retired, includes far jump, far call and return, and Interrupt call and return",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.FAR_BRANCH",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xbf",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Indirect near branch instructions retired (excluding returns)",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.INDIRECT",
        "PEBS": "1",
        "PublicDescription": "Counts near indirect branch instructions retired excluding returns. TSX abort is an indirect branch.",
        "SampleAfterValue": "100003",
        "UMask": "0x80",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of near indirect JMP and near indirect CALL branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.INDIRECT",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xeb",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of near indirect CALL branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.INDIRECT_CALL",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xfb",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Direct and indirect near call instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_CALL",
        "PEBS": "1",
        "PublicDescription": "Counts both direct and indirect near call instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of near CALL branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_CALL",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xf9",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Return instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_RETURN",
        "PEBS": "1",
        "PublicDescription": "Counts return instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of near RET branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_RETURN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xf7",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Taken branch instructions retired.",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_TAKEN",
        "PEBS": "1",
        "PublicDescription": "Counts taken branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of near relative CALL branch instructions retired",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REL_CALL",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xfd",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of taken branch instructions retired (by removing not taken JCC branches)",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_COND_NTAKEN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x80",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of branch instructions retired but removes taken JCC",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_COND_TAKEN",
        "PEBS": "1",
        "PublicDescription": "Counts the number of branch instructions retired but removes JCC",
        "SampleAfterValue": "200003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of branch instructions retired but removes all far branches",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_FAR",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x40",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of branch instructions retired but removes near indirect CALL",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_INDIRECT_CALL",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of branch instructions retired but removes near indirect JMP",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_INDIRECT_JMP",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of branch instructions retired but removes near RET",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_NEAR_RETURN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of branch instructions retired but removes near relative CALL",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_REL_CALL",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of branch instructions retired but removes near relative JMP",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.REMOVE_REL_JMP",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x20",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "All mispredicted branch instructions retired.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.ALL_BRANCHES",
        "PEBS": "1",
        "PublicDescription": "Counts all the retired branch instructions that were mispredicted by the processor. A branch misprediction occurs when the processor incorrectly predicts the destination of the branch.  When the misprediction is discovered at execution, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path.",
        "SampleAfterValue": "400009",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the total number of mispredicted branch instructions retired for all branch types.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.ALL_BRANCHES",
        "PEBS": "1",
        "PublicDescription": "Counts the total number of mispredicted branch instructions retired.  All branch type instructions are accounted for.  Prediction of the branch target address enables the processor to begin executing instructions before the non-speculative execution path is known. The branch prediction unit (BPU) predicts the target address based on the instruction pointer (IP) of the branch and on the execution path through which execution reached this IP.    A branch misprediction occurs when the prediction is wrong, and results in discarding all instructions executed in the speculative path and re-fetching from the correct path.",
        "SampleAfterValue": "200003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "All mispredicted branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.ALL_BRANCHES_COST",
        "PEBS": "1",
        "SampleAfterValue": "400009",
        "UMask": "0x44",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Mispredicted conditional branch instructions retired.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND",
        "PEBS": "1",
        "PublicDescription": "Counts mispredicted conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x111",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of mispredicted JCC branch instructions retired",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x7e",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Mispredicted conditional branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_COST",
        "PEBS": "1",
        "SampleAfterValue": "400009",
        "UMask": "0x151",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Mispredicted non-taken conditional branch instructions retired.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_NTAKEN",
        "PEBS": "1",
        "PublicDescription": "Counts the number of conditional branch instructions retired that were mispredicted and the branch direction was not taken.",
        "SampleAfterValue": "400009",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of mispredicted not taken JCC branch instructions retired",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_NTAKEN",
        "SampleAfterValue": "1000003",
        "UMask": "0x7f",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Mispredicted non-taken conditional branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_NTAKEN_COST",
        "PEBS": "1",
        "SampleAfterValue": "400009",
        "UMask": "0x50",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "number of branch instructions retired that were mispredicted and taken.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN",
        "PEBS": "1",
        "PublicDescription": "Counts taken conditional mispredicted branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x101",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of mispredicted taken JCC branch instructions retired",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xfe",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "number of branch instructions retired that were mispredicted and taken backward.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN_BWD",
        "PEBS": "1",
        "PublicDescription": "Counts taken backward conditional mispredicted branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Mispredicted taken conditional branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN_COST",
        "PEBS": "1",
        "SampleAfterValue": "400009",
        "UMask": "0x141",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "number of branch instructions retired that were mispredicted and taken forward.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN_FWD",
        "PEBS": "1",
        "PublicDescription": "Counts taken forward conditional mispredicted branch instructions retired.",
        "SampleAfterValue": "400009",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Miss-predicted near indirect branch instructions retired (excluding returns)",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT",
        "PEBS": "1",
        "PublicDescription": "Counts miss-predicted near indirect branch instructions retired excluding returns. TSX abort is an indirect branch.",
        "SampleAfterValue": "100003",
        "UMask": "0x80",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of mispredicted near indirect JMP and near indirect CALL branch instructions retired",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xeb",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Mispredicted indirect CALL retired.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_CALL",
        "PEBS": "1",
        "PublicDescription": "Counts retired mispredicted indirect (near taken) CALL instructions, including both register and memory indirect.",
        "SampleAfterValue": "400009",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of mispredicted near indirect CALL branch instructions retired",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_CALL",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xfb",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Mispredicted indirect CALL retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_CALL_COST",
        "PEBS": "1",
        "SampleAfterValue": "400009",
        "UMask": "0x42",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Mispredicted near indirect branch instructions retired (excluding returns). This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_COST",
        "PEBS": "1",
        "SampleAfterValue": "100003",
        "UMask": "0xc0",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of near branch instructions retired that were mispredicted and taken.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.NEAR_TAKEN",
        "PEBS": "1",
        "PublicDescription": "Counts number of near branch instructions retired that were mispredicted and taken.",
        "SampleAfterValue": "400009",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Mispredicted taken near branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.NEAR_TAKEN_COST",
        "PEBS": "1",
        "SampleAfterValue": "400009",
        "UMask": "0x60",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of mispredicted branch instructions retired but removes not taken JCC",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.REMOVE_COND_NTAKEN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x80",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of mispredicted branch instructions retired but removes taken JCC",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.REMOVE_COND_TAKEN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of mispredicted branch instructions retired but removes near indirect CALL",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.REMOVE_INDIRECT_CALL",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of mispredicted branch instructions retired but removes near indirect JMP",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.REMOVE_INDIRECT_JMP",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of mispredicted branch instructions retired but removes near RET",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.REMOVE_NEAR_RETURN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "This event counts the number of mispredicted ret instructions retired. Non PEBS",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.RET",
        "PEBS": "1",
        "PublicDescription": "This is a non-precise version (that is, does not use PEBS) of the event that counts mispredicted return instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of mispredicted near RET branch instructions retired",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.RETURN",
        "PEBS": "1",
        "SampleAfterValue": "200003",
        "UMask": "0xf7",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Mispredicted ret instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.RET_COST",
        "PEBS": "1",
        "SampleAfterValue": "100007",
        "UMask": "0x48",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the total number of BTCLEARS.",
        "EventCode": "0xe8",
        "EventName": "BTCLEAR.ANY",
        "PublicDescription": "Counts the total number of BTCLEARS which occurs when the Branch Target Buffer (BTB) predicts a taken branch.",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Core clocks when the thread is in the C0.1 light-weight slower wakeup time but more power saving optimized state.",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.C01",
        "PublicDescription": "Counts core clocks when the thread is in the C0.1 light-weight slower wakeup time but more power saving optimized state.  This state can be entered via the TPAUSE or UMWAIT instructions.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Core clocks when the thread is in the C0.2 light-weight faster wakeup time but less power saving optimized state.",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.C02",
        "PublicDescription": "Counts core clocks when the thread is in the C0.2 light-weight faster wakeup time but less power saving optimized state.  This state can be entered via the TPAUSE or UMWAIT instructions.",
        "SampleAfterValue": "2000003",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Core clocks when the thread is in the C0.1 or C0.2 or running a PAUSE in C0 ACPI state.",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.C0_WAIT",
        "PublicDescription": "Counts core clocks when the thread is in the C0.1 or C0.2 power saving optimized states (TPAUSE or UMWAIT instructions) or running the PAUSE instruction.",
        "SampleAfterValue": "2000003",
        "UMask": "0x70",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Fixed Counter: Counts the number of unhalted core clock cycles",
        "EventName": "CPU_CLK_UNHALTED.CORE",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of unhalted core clock cycles [This event is alias to CPU_CLK_UNHALTED.THREAD_P]",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.CORE_P",
        "SampleAfterValue": "2000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "CPU_CLK_UNHALTED.PAUSE",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.PAUSE",
        "SampleAfterValue": "2000003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "CPU_CLK_UNHALTED.PAUSE_INST",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.PAUSE_INST",
        "SampleAfterValue": "2000003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Reference cycles when the core is not in halt state.",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC",
        "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. It is counted on a dedicated fixed counter, leaving the eight programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
        "SampleAfterValue": "2000003",
        "UMask": "0x3",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Fixed Counter: Counts the number of unhalted reference clock cycles",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC",
        "SampleAfterValue": "1000003",
        "UMask": "0x3",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Reference cycles when the core is not in halt state.",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC_P",
        "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. It is counted on a dedicated fixed counter, leaving the four (eight when Hyperthreading is disabled) programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of unhalted reference clock cycles",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC_P",
        "PublicDescription": "Counts the number of reference cycles that the core is not in a halt state. The core enters the halt state when it is running the HLT instruction. This event is not affected by core frequency changes and increments at a fixed frequency that is also used for the Time Stamp Counter (TSC). This event uses a programmable general purpose performance counter.",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Core crystal clock cycles when the thread is unhalted.",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.REF_XCLK",
        "PublicDescription": "Counts core crystal clock cycles when the thread is unhalted.",
        "SampleAfterValue": "25003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Core cycles when the thread is not in halt state",
        "EventName": "CPU_CLK_UNHALTED.THREAD",
        "PublicDescription": "Counts the number of core cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. This event is a component in many key event ratios. The core frequency may change from time to time due to transitions associated with Enhanced Intel SpeedStep Technology or TM2. For this reason this event may have a changing ratio with regards to time. When the core frequency is constant, this event can approximate elapsed time while the core was not in the halt state. It is counted on a dedicated fixed counter, leaving the eight programmable counters available for other events.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Fixed Counter: Counts the number of unhalted core clock cycles",
        "EventName": "CPU_CLK_UNHALTED.THREAD",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Thread cycles when thread is not in halt state",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.THREAD_P",
        "PublicDescription": "This is an architectural event that counts the number of thread cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. The core frequency may change from time to time due to power or thermal throttling. For this reason, this event may have a changing ratio with regards to wall clock time.",
        "SampleAfterValue": "2000003",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of unhalted core clock cycles [This event is alias to CPU_CLK_UNHALTED.CORE_P]",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.THREAD_P",
        "SampleAfterValue": "2000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Cycles while L1 cache miss demand load is outstanding.",
        "CounterMask": "8",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_L1D_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles while L2 cache miss demand load is outstanding.",
        "CounterMask": "1",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_L2_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles while memory subsystem has an outstanding load.",
        "CounterMask": "16",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_MEM_ANY",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Execution stalls while L1 cache miss demand load is outstanding.",
        "CounterMask": "12",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L1D_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0xc",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Execution stalls while L2 cache miss demand load is outstanding.",
        "CounterMask": "5",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L2_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0x5",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Execution stalls while memory subsystem has an outstanding load.",
        "CounterMask": "20",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_MEM_ANY",
        "SampleAfterValue": "1000003",
        "UMask": "0x14",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Total execution stalls.",
        "CounterMask": "4",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_TOTAL",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles no uop executed while RS was not empty",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.0_PORTS_UTIL",
        "PublicDescription": "Number of cycles total of 0 uops executed on all ports, RS was not empty and thread was active.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles total of 1 uop is executed on all ports and Reservation Station was not empty.",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.1_PORTS_UTIL",
        "PublicDescription": "Counts cycles during which a total of 1 uop was executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "EXE_ACTIVITY.2_3_PORTS_UTIL",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.2_3_PORTS_UTIL",
        "SampleAfterValue": "2000003",
        "UMask": "0xc",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles total of 2 uops are executed on all ports and Reservation Station was not empty.",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.2_PORTS_UTIL",
        "PublicDescription": "Counts cycles during which a total of 2 uops were executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles total of 3 uops are executed on all ports and Reservation Station was not empty.",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.3_PORTS_UTIL",
        "PublicDescription": "Cycles total of 3 uops are executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles total of 4 uops are executed on all ports and Reservation Station was not empty.",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.4_PORTS_UTIL",
        "PublicDescription": "Cycles total of 4 uops are executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Execution stalls while memory subsystem has an outstanding load.",
        "CounterMask": "5",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.BOUND_ON_LOADS",
        "SampleAfterValue": "2000003",
        "UMask": "0x21",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles where the Store Buffer was full and no loads caused an execution stall.",
        "CounterMask": "2",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.BOUND_ON_STORES",
        "PublicDescription": "Counts cycles where the Store Buffer was full and no loads caused an execution stall.",
        "SampleAfterValue": "1000003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles no uop executed while RS was not empty, the SB was not full and there was no outstanding load.",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.EXE_BOUND_0_PORTS",
        "PublicDescription": "Number of cycles total of 0 uops executed on all ports, Reservation Station (RS) was not empty, the Store Buffer (SB) was not full and there was no outstanding load.",
        "SampleAfterValue": "1000003",
        "UMask": "0x80",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles when the memory subsystem has an outstanding load. Increments by 4 for every such cycle.",
        "CounterMask": "4",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.LOAD_PENDING_CYCLES",
        "PublicDescription": "Counts cycles when the memory subsystem has an outstanding load. Increments by 4 for every such cycle.",
        "SampleAfterValue": "2000003",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Instruction decoders utilized in a cycle",
        "EventCode": "0x75",
        "EventName": "INST_DECODED.DECODERS",
        "PublicDescription": "Number of decoders utilized in a cycle when the MITE (legacy decode pipeline) fetches instructions.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "INST_DECODED.UNFUSED",
        "EventCode": "0x75",
        "EventName": "INST_DECODED.UNFUSED",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of instructions retired. Fixed Counter - architectural event",
        "EventName": "INST_RETIRED.ANY",
        "PEBS": "1",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Fixed Counter: Counts the number of instructions retired",
        "EventName": "INST_RETIRED.ANY",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Number of instructions retired. General Counter - architectural event",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.ANY_P",
        "PEBS": "1",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "SampleAfterValue": "2000003",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of instructions retired",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.ANY_P",
        "PEBS": "1",
        "SampleAfterValue": "2000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Number of instructions retired. General Counter - architectural event",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.ANY_PEBS",
        "PEBS": "1",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "SampleAfterValue": "2000003",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "retired macro-fused uops when there is a branch in the macro-fused pair (the two instructions that got macro-fused count once in this pmon)",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.BR_FUSED",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "INST_RETIRED.MACRO_FUSED",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.MACRO_FUSED",
        "SampleAfterValue": "2000003",
        "UMask": "0x30",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "retired macro-fused uops when there is no branch in the macro-fused pair (the two instructions that got macro-fused count once in this pmon)",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.NONBR_FUSED",
        "SampleAfterValue": "1000003",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Retired NOP instructions.",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.NOP",
        "PublicDescription": "Counts all retired NOP or ENDBR32/64 or PREFETCHIT0/1 instructions",
        "SampleAfterValue": "2000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Precise instruction retired with PEBS precise-distribution",
        "EventName": "INST_RETIRED.PREC_DIST",
        "PEBS": "1",
        "PublicDescription": "A version of INST_RETIRED that allows for a precise distribution of samples across instructions retired. It utilizes the Precise Distribution of Instructions Retired (PDIR++) feature to fix bias in how retired instructions get sampled. Use on Fixed Counter 0.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Iterations of Repeat string retired instructions.",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.REP_ITERATION",
        "PublicDescription": "Number of iterations of Repeat (REP) string retired instructions such as MOVS, CMPS, and SCAS. Each has a byte, word, and doubleword version and string instructions can be repeated using a repetition prefix, REP, that allows their architectural execution to be repeated a number of times as specified by the RCX register. Note the number of iterations is implementation-dependent.",
        "SampleAfterValue": "2000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of Instructions Retired  while the PacketEn bit is set",
        "EventCode": "0x70",
        "EventName": "INTEL_PT.INST_RETIRED_PACKET_EN",
        "PEBS": "1",
        "SampleAfterValue": "2000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of Instructions Retired  while the PacketEn bit is set and PT has overflowed",
        "EventCode": "0x70",
        "EventName": "INTEL_PT.INST_RETIRED_PACKET_EN_OVF",
        "PEBS": "1",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Cycles the Backend cluster is recovering after a miss-speculation or a Store Buffer or Load Buffer drain stall.",
        "CounterMask": "1",
        "EventCode": "0xad",
        "EventName": "INT_MISC.ALL_RECOVERY_CYCLES",
        "PublicDescription": "Counts cycles the Backend cluster is recovering after a miss-speculation or a Store Buffer or Load Buffer drain stall.",
        "SampleAfterValue": "2000003",
        "UMask": "0x3",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Bubble cycles of BPClear.",
        "EventCode": "0xad",
        "EventName": "INT_MISC.BPCLEAR_CYCLES",
        "MSRIndex": "0x3F7",
        "MSRValue": "0xB",
        "SampleAfterValue": "1000003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Clears speculative count",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xad",
        "EventName": "INT_MISC.CLEARS_COUNT",
        "PublicDescription": "Counts the number of speculative clears due to any type of branch misprediction or machine clears",
        "SampleAfterValue": "500009",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts cycles after recovery from a branch misprediction or machine clear till the first uop is issued from the resteered path.",
        "EventCode": "0xad",
        "EventName": "INT_MISC.CLEAR_RESTEER_CYCLES",
        "PublicDescription": "Cycles after recovery from a branch misprediction or machine clear till the first uop is issued from the resteered path.",
        "SampleAfterValue": "500009",
        "UMask": "0x80",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Stall cycles due to SB/LB drain cycles. SB drain may apply after Nukes, while LB drain applies for HLE senior loads.",
        "EventCode": "0xad",
        "EventName": "INT_MISC.MEM_DRAIN",
        "SampleAfterValue": "100003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles when Resource Allocation Table (RAT) external stall is sent to Instruction Decode Queue (IDQ) for the thread",
        "EventCode": "0xad",
        "EventName": "INT_MISC.RAT_STALLS",
        "PublicDescription": "This event counts the number of cycles during which Resource Allocation Table (RAT) external stall is sent to Instruction Decode Queue (IDQ) for the current thread. This also includes the cycles during which the Allocator is serving another thread.",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Core cycles the allocator was stalled due to recovery from earlier clear event for this thread",
        "EventCode": "0xad",
        "EventName": "INT_MISC.RECOVERY_CYCLES",
        "PublicDescription": "Counts core cycles when the Resource allocator was stalled due to recovery from an earlier branch misprediction or machine clear event.",
        "SampleAfterValue": "500009",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "INT_MISC.SMT_STALLS",
        "EventCode": "0xad",
        "EventName": "INT_MISC.SMT_STALLS",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Bubble cycles of BAClear (Unknown Branch).",
        "EventCode": "0xad",
        "EventName": "INT_MISC.UNKNOWN_BRANCH_CYCLES",
        "MSRIndex": "0x3F7",
        "MSRValue": "0x7",
        "SampleAfterValue": "1000003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "TMA slots where uops got dropped",
        "EventCode": "0xad",
        "EventName": "INT_MISC.UOP_DROPPING",
        "PublicDescription": "Estimated number of Top-down Microarchitecture Analysis slots that got dropped due to non front-end reasons",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of vector integer instructions retired of 128-bit vector-width.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.128BIT",
        "SampleAfterValue": "1000003",
        "UMask": "0x13",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of vector integer instructions retired of 256-bit vector-width.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.256BIT",
        "SampleAfterValue": "1000003",
        "UMask": "0xac",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "integer ADD, SUB, SAD 128-bit vector instructions.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.ADD_128",
        "PublicDescription": "Number of retired integer ADD/SUB (regular or horizontal), SAD 128-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0x3",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "integer ADD, SUB, SAD 256-bit vector instructions.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.ADD_256",
        "PublicDescription": "Number of retired integer ADD/SUB (regular or horizontal), SAD 256-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0xc",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "integer horizontal ADD, SUB, SAD 128-bit vector instructions.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.HADD_128",
        "PublicDescription": "Number of retired integer horizontal ADD/SUB, SAD 128-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "integer horizontal ADD, SUB, SAD 256-bit vector instructions.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.HADD_256",
        "PublicDescription": "Number of retired integer horizontal ADD/SUB, SAD 256-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.MUL_256",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.MUL_256",
        "SampleAfterValue": "1000003",
        "UMask": "0x80",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "integer regular ADD, SUB, SAD 128-bit vector instructions.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.R_ADD_128",
        "PublicDescription": "Number of retired integer regular ADD/SUB, SAD 128-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "integer regular ADD, SUB, SAD 256-bit vector instructions.",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.R_ADD_256",
        "PublicDescription": "Number of retired integer regular ADD/SUB, SAD 256-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.SHUFFLES",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.SHUFFLES",
        "SampleAfterValue": "1000003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.VNNI_128",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.VNNI_128",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.VNNI_256",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.VNNI_256",
        "SampleAfterValue": "1000003",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "False dependencies in MOB due to partial compare on address.",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.ADDRESS_ALIAS",
        "PublicDescription": "Counts the number of times a load got blocked due to false dependencies in MOB due to partial compare on address.",
        "SampleAfterValue": "100003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of occurrences that a retired load gets blocked because it initially appears to be store forward blocked, but subsequently is shown not to be blocked based on 4K alias check.",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.ADDRESS_ALIAS",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of occurrences a retired load was blocked for any of the following reasons:  utlb_miss, 4k_alias, unknown_sta/bad_fwd, unready_fwd (includes md blocks and esp consuming load blocks)",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.ALL",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Loads delayed due to SB blocks, preceding store operations with known addresses but unknown data.",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.DATA_UNKNOWN",
        "PublicDescription": "Counts the number of times a load got blocked due to preceding store operation with known address and unknown data.",
        "SampleAfterValue": "100003",
        "UMask": "0x81",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of occurences a retired load gets blocked because its address exactly matches an older store whose data is not ready (a.k.a. unknown).  unready_fwd",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.DATA_UNKNOWN",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "The number of times that split load operations are temporarily blocked because all resources for handling the split accesses are in use.",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.NO_SR",
        "PublicDescription": "Counts the number of times that split load operations are temporarily blocked because all resources for handling the split accesses are in use.",
        "SampleAfterValue": "100003",
        "UMask": "0x88",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Load operations delayed due to the store buffer blocks",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_ADDR_BLK",
        "PublicDescription": "Counts the number of times a load got blocked due to preceding store operation with unknown address.",
        "SampleAfterValue": "100003",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "counts loads Block-on-STORE block-code (excludes unknown STA)",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_BLOCK",
        "PublicDescription": "This event counts the total number of times when a load gets the Block-on-STORE block code, that is the load is blocked until the colliding store is committed to the cache. This includes total cases as a result of the software (for example, incomplete overlap, load hitting store_unlock, and so on) or hardware restrictions (for example, SbTailHit, limitation in Rotator, and so on). This counter is a super set for all block-on-STORE derived counters.",
        "SampleAfterValue": "100003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of times a load got early blocked due to preceding store operation with unknown address or unknown data. Excluding in-line (immediate) wakeups",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_EARLY",
        "SampleAfterValue": "100003",
        "UMask": "0xc1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Loads blocked due to overlapping with a preceding store that cannot be forwarded.",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_FORWARD",
        "PublicDescription": "Counts the number of times where store forwarding was prevented for a load operation. The most common case is a load blocked due to the address of memory access (partially) overlapping with a preceding uncompleted store. Note: See the table of not supported store forwards in the Optimization Guide.",
        "SampleAfterValue": "100003",
        "UMask": "0x82",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of occurences a retired load gets blocked because its address partially overlaps with an older store (size mismatch) - unknown_sta/bad_forward",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_FORWARD",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Load dispatches that hit L1D fill buffer (FB) allocated for hardware prefetch.",
        "EventCode": "0x4c",
        "EventName": "LOAD_HIT_PRE.HW_PF",
        "PublicDescription": "This event counts all not software-prefetch load dispatches that hit the fill buffer (FB) allocated for the hardware prefetch.",
        "SampleAfterValue": "100003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of demand loads that match on a wcb (request buffer) allocated by an L1 hardware prefetch",
        "EventCode": "0x4c",
        "EventName": "LOAD_HIT_PREFETCH.HW_PF",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of demand load dispatches that hit L1D fill buffer (FB) allocated for software prefetch.",
        "EventCode": "0x4c",
        "EventName": "LOAD_HIT_PREFETCH.SWPF",
        "PublicDescription": "Counts all not software-prefetch load dispatches that hit the fill buffer (FB) allocated for the software prefetch. It can also be incremented by some lock instructions. So it should only be used with profiling so that the locks can be excluded by ASM (Assembly File) inspection of the nearby instructions.",
        "SampleAfterValue": "100003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of demand loads that match on a wcb (request buffer) allocated by a  software prefetch",
        "EventCode": "0x4c",
        "EventName": "LOAD_HIT_PREFETCH.SW_PF",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Cycles Uops delivered by the LSD, but didn't come from the decoder.",
        "CounterMask": "1",
        "EventCode": "0xa8",
        "EventName": "LSD.CYCLES_ACTIVE",
        "PublicDescription": "Counts the cycles when at least one uop is delivered by the LSD (Loop-stream detector).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles optimal number of Uops delivered by the LSD, but did not come from the decoder.",
        "CounterMask": "8",
        "EventCode": "0xa8",
        "EventName": "LSD.CYCLES_OK",
        "PublicDescription": "Counts the cycles when optimal number of uops is delivered by the LSD (Loop-stream detector).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of Uops delivered by the LSD.",
        "EventCode": "0xa8",
        "EventName": "LSD.UOPS",
        "PublicDescription": "Counts the number of uops delivered to the back-end by the LSD(Loop Stream Detector).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts LSD Aborts. An LSD Abort indicates a stream is stopped to be recognized as LSD-able candidate stream.",
        "EventCode": "0x7f",
        "EventName": "LSD_REPLAY.ABORTS",
        "SampleAfterValue": "100003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts all machine clears for any reason including, but not limited to memory ordering, SMC, and FP assist.",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.ANY",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Number of machine clears (nukes) of any type.",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.COUNT",
        "PublicDescription": "Counts the number of machine clears (nukes) of any type.",
        "SampleAfterValue": "100003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of memory ordering machine clears triggered due to an internal load passing an older store within the same CPU.",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.DISAMBIGUATION",
        "SampleAfterValue": "20003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts number of virtual trap actually taken (e.g. highest priority event during retirement). It can count virtual trap from FPC port 0 or port 1 (x87/SSE) equally in a single counter.",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.FPC_VIRTUAL_TRAP",
        "SampleAfterValue": "1000003",
        "UMask": "0x40",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of nukes due to memory renaming",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.MRN_NUKE",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Cycles there was a Nuke. Account for both thread-specific and All Thread Nukes.",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.NUKE_ASSERTED",
        "PublicDescription": "This event counts both thread-specific (TS) and all-thread (AT) nukes.",
        "SampleAfterValue": "100003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of times that the machine clears due to a page fault.  Covers both I-Side and D-Side (Loads/Stores) page faults.  A page fault occurs when either the page is not present, or an access violation.",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.PAGE_FAULT",
        "SampleAfterValue": "20003",
        "UMask": "0x20",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of machine clears that flush the pipeline and restart the machine with the use of microcode due to SMC, MEMORY_ORDERING, FP_ASSISTS, PAGE_FAULT, DISAMBIGUATION, and FPC_VIRTUAL_TRAP.",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.SLOW",
        "SampleAfterValue": "1000003",
        "UMask": "0x6e",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Self-modifying code (SMC) detected.",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.SMC",
        "PublicDescription": "Counts self-modifying code (SMC) detected, which causes a machine clear.",
        "SampleAfterValue": "100003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "LFENCE instructions retired",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.LFENCE",
        "PublicDescription": "number of LFENCE retired instructions",
        "SampleAfterValue": "400009",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts all PT microcode assists",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.PT_ASSIST",
        "SampleAfterValue": "1000003",
        "UMask": "0x25",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of user-level interrupts received.",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.ULI_RECEIVED",
        "PublicDescription": "MISC2_RETIRED.ULI_RECEIVED",
        "SampleAfterValue": "400009",
        "UMask": "0x21",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of user-level interrupts sent through SENDUIPI instruction.",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.ULI_SENT",
        "PublicDescription": "MISC2_RETIRED.ULI_SENT",
        "SampleAfterValue": "400009",
        "UMask": "0x22",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts all VM-entry flows. Covers parallel and vertical entries",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.VM_ENTRY",
        "SampleAfterValue": "1000003",
        "UMask": "0x24",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "WRMSR instructions retired",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.WRMSR",
        "PublicDescription": "MISC2_RETIRED.WRMSR",
        "SampleAfterValue": "400009",
        "UMask": "0x23",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "LBR record is inserted",
        "EventCode": "0xe4",
        "EventName": "MISC3_RETIRED.LBR_INSERTS",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "PTWRITE instructions retired",
        "EventCode": "0xe4",
        "EventName": "MISC3_RETIRED.PTWRITE",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "MISC_RETIRED.MEM_FAULT",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.MEM_FAULT",
        "SampleAfterValue": "100003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "MISC_RETIRED.PAUSE",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.PAUSE",
        "SampleAfterValue": "100003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "MISC_RETIRED.PT_OVERFLOW",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.PT_OVERFLOW",
        "SampleAfterValue": "101",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts Monitored Region entries. Requires some configuration through Intel PT.",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.REGION_ENTRY",
        "SampleAfterValue": "100003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts Monitored Region exits. Requires some configuration through Intel PT.",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.REGION_EXIT",
        "SampleAfterValue": "100003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts retired x87 special instructions when no assist is required. namely FYL2X/FYL2XP1 F2XM1 FNCLEX FSCALE FNINIT FLDCW FRNDINT",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.X87_SPECIAL",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of CLFLUSH, CLWB, and CLDEMOTE instructions retired.",
        "EventCode": "0xe0",
        "EventName": "MISC_RETIRED1.CL_INST",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0xff",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of LFENCE instructions retired.",
        "EventCode": "0xe0",
        "EventName": "MISC_RETIRED1.LFENCE",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of RDPMC, RDTSC, and RDTSCP instructions retired.",
        "EventCode": "0xe0",
        "EventName": "MISC_RETIRED1.RDPMC_RDTSC_P",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Count the number of WRMSR instructions retired.",
        "EventCode": "0xe0",
        "EventName": "MISC_RETIRED1.WRMSR",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of faults and software interrupts with vector < 32.",
        "EventCode": "0xe1",
        "EventName": "MISC_RETIRED2.FAULT_ALL",
        "PEBS": "1",
        "PublicDescription": "Counts the number of faults and software interrupts with vector < 32, including VOE cases.",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of PSB+ nuke events and ToPA trap events.",
        "EventCode": "0xe1",
        "EventName": "MISC_RETIRED2.INTEL_PT_CLEARS",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of accesses to KeyLocker cache.",
        "EventCode": "0xe1",
        "EventName": "MISC_RETIRED2.KEYLOCKER_ACCESS",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of misses to KeyLocker cache.",
        "EventCode": "0xe1",
        "EventName": "MISC_RETIRED2.KEYLOCKER_MISS",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x11",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of user interrupts delivered.",
        "EventCode": "0xe1",
        "EventName": "MISC_RETIRED2.ULI_DELIVERY",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of SENDUIPI instructions retired.",
        "EventCode": "0xe1",
        "EventName": "MISC_RETIRED2.ULI_SENDUIPI",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x9",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of VM exits.",
        "EventCode": "0xe1",
        "EventName": "MISC_RETIRED2.VM_EXIT",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of entries into a Monitored Region",
        "EventCode": "0xcc",
        "EventName": "ROB_MISC_EVENTS.REGION_ENTRY",
        "PublicDescription": "Counts Monitored Region entries. A Monitored Region is configured through RTIT MSRs (e.g. IA32_RTIT_CTL) though RTIT itself does not need to be enabled (TraceEn). Count on the first instruction retired right after a region is entered, once per whole region execution, skid permitted.",
        "SampleAfterValue": "200003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of exits from a Monitored Region",
        "EventCode": "0xcc",
        "EventName": "ROB_MISC_EVENTS.REGION_EXIT",
        "PublicDescription": "Counts Monitored Region exits. A Monitored Region is configured through RTIT MSRs (e.g. IA32_RTIT_CTL) though RTIT itself does not need to be enabled (TraceEn). Count on the first instruction right after all regions are exited, once per whole region execution, skid permitted.",
        "SampleAfterValue": "200003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots not consumed by the backend due to a micro-sequencer (MS) scoreboard, which stalls the front-end from issuing from the UROM until a specified older uop retires.",
        "EventCode": "0x75",
        "EventName": "SERIALIZATION.NON_C01_MS_SCB",
        "PublicDescription": "Counts the number of issue slots not consumed by the backend due to a micro-sequencer (MS) scoreboard, which stalls the front-end from issuing from the UROM until a specified older uop retires. The most commonly executed instruction with an MS scoreboard is PAUSE.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "This event counts a subset of the Topdown Slots event that were not consumed by the back-end pipeline due to lack of back-end resources, as a result of memory subsystem delays, execution units limitations, or other conditions.",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BACKEND_BOUND_SLOTS",
        "PublicDescription": "This event counts a subset of the Topdown Slots event that were not consumed by the back-end pipeline due to lack of back-end resources, as a result of memory subsystem delays, execution units limitations, or other conditions.\nThe count is distributed among unhalted logical processors (hyper-threads) who share the same physical core, in processors that support Intel Hyper-Threading Technology. Software can use this event as the numerator for the Backend Bound metric (or top-level category) of the Top-down Microarchitecture Analysis method.",
        "SampleAfterValue": "10000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "TMA slots wasted due to incorrect speculations.",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BAD_SPEC_SLOTS",
        "PublicDescription": "Number of slots of TMA method that were wasted due to incorrect speculation. It covers all types of control-flow or data-related mis-speculations.",
        "SampleAfterValue": "10000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "TMA slots wasted due to incorrect speculation by branch mispredictions",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BR_MISPREDICT_SLOTS",
        "PublicDescription": "Number of TMA slots that were wasted due to incorrect speculation by (any type of) branch mispredictions. This event estimates number of speculative operations that were issued but not retired as well as the out-of-order engine recovery past a branch misprediction.",
        "SampleAfterValue": "10000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "TOPDOWN.MEMORY_BOUND_SLOTS",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.MEMORY_BOUND_SLOTS",
        "SampleAfterValue": "10000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "TMA slots available for an unhalted logical processor. Fixed counter - architectural event",
        "EventName": "TOPDOWN.SLOTS",
        "PublicDescription": "Number of available slots for an unhalted logical processor. The event increments by machine-width of the narrowest pipeline as employed by the Top-down Microarchitecture Analysis method (TMA). The count is distributed among unhalted logical processors (hyper-threads) who share the same physical core. Software can use this event as the denominator for the top-level metrics of the TMA method. This architectural event is counted on a designated fixed counter (Fixed Counter 3).",
        "SampleAfterValue": "10000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "TMA slots available for an unhalted logical processor. General counter - architectural event",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.SLOTS_P",
        "PublicDescription": "Counts the number of available slots for an unhalted logical processor. The event increments by machine-width of the narrowest pipeline as employed by the Top-down Microarchitecture Analysis method. The count is distributed among unhalted logical processors (hyper-threads) who share the same physical core.",
        "SampleAfterValue": "10000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Fixed Counter: Counts the number of issue slots that were not consumed by the backend because allocation is stalled due to a mispredicted jump or a machine clear.",
        "EventName": "TOPDOWN_BAD_SPECULATION.ALL",
        "PublicDescription": "Fixed Counter: Counts the number of issue slots that were not consumed by the backend because allocation is stalled due to a mispredicted jump or a machine clear.  Counts all issue slots blocked during this recovery window including relevant microcode flows and while uops are not yet available in the IQ. Also, includes the issue slots that were consumed by the backend but were thrown away because they were younger than the mispredict or machine clear.",
        "SampleAfterValue": "1000003",
        "UMask": "0x5",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots that were not consumed by the backend because allocation is stalled due to a mispredicted jump or a machine clear.",
        "EventCode": "0x73",
        "EventName": "TOPDOWN_BAD_SPECULATION.ALL_P",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to Fast Nukes such as  Memory Ordering Machine clears and MRN nukes",
        "EventCode": "0x73",
        "EventName": "TOPDOWN_BAD_SPECULATION.FASTNUKE",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the total number of issue slots that were not consumed by the backend because allocation is stalled due to a machine clear (nuke) of any kind including memory ordering and memory disambiguation.",
        "EventCode": "0x73",
        "EventName": "TOPDOWN_BAD_SPECULATION.MACHINE_CLEARS",
        "SampleAfterValue": "1000003",
        "UMask": "0x3",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to Branch Mispredict",
        "EventCode": "0x73",
        "EventName": "TOPDOWN_BAD_SPECULATION.MISPREDICT",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to a machine clear (nuke).",
        "EventCode": "0x73",
        "EventName": "TOPDOWN_BAD_SPECULATION.NUKE",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of retirement slots not consumed due to backend stalls [This event is alias to TOPDOWN_BE_BOUND.ALL_P]",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN_BE_BOUND.ALL",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to due to certain allocation restrictions",
        "EventCode": "0x74",
        "EventName": "TOPDOWN_BE_BOUND.ALLOC_RESTRICTIONS",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of retirement slots not consumed due to backend stalls",
        "EventCode": "0x74",
        "EventName": "TOPDOWN_BE_BOUND.ALL_NON_ARCH",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of retirement slots not consumed due to backend stalls [This event is alias to TOPDOWN_BE_BOUND.ALL]",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN_BE_BOUND.ALL_P",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to memory reservation stall (scheduler not being able to accept another uop).  This could be caused by RSV full or load/store buffer block.",
        "EventCode": "0x74",
        "EventName": "TOPDOWN_BE_BOUND.MEM_SCHEDULER",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to IEC and FPC RAT stalls - which can be due to the FIQ and IEC reservation station stall (integer, FP and SIMD scheduler not being able to accept another uop. )",
        "EventCode": "0x74",
        "EventName": "TOPDOWN_BE_BOUND.NON_MEM_SCHEDULER",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to mrbl stall.  A 'marble' refers to a physical register file entry, also known as the physical destination (PDST).",
        "EventCode": "0x74",
        "EventName": "TOPDOWN_BE_BOUND.REGISTER",
        "SampleAfterValue": "1000003",
        "UMask": "0x20",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to ROB full",
        "EventCode": "0x74",
        "EventName": "TOPDOWN_BE_BOUND.REORDER_BUFFER",
        "SampleAfterValue": "1000003",
        "UMask": "0x40",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not consumed by the backend due to iq/jeu scoreboards or ms scb",
        "EventCode": "0x74",
        "EventName": "TOPDOWN_BE_BOUND.SERIALIZATION",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Fixed Counter: Counts the number of retirement slots not consumed due to front end stalls",
        "EventName": "TOPDOWN_FE_BOUND.ALL",
        "SampleAfterValue": "1000003",
        "UMask": "0x6",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of retirement slots not consumed due to front end stalls",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.ALL_NON_ARCH",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of retirement slots not consumed due to front end stalls",
        "EventCode": "0x9c",
        "EventName": "TOPDOWN_FE_BOUND.ALL_P",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to BAClear",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.BRANCH_DETECT",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to BTClear",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.BRANCH_RESTEER",
        "SampleAfterValue": "1000003",
        "UMask": "0x40",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to ms",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.CISC",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to decode stall",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.DECODE",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to frontend bandwidth restrictions due to decode, predecode, cisc, and other limitations.",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.FRONTEND_BANDWIDTH",
        "SampleAfterValue": "1000003",
        "UMask": "0x8d",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to latency related stalls including BACLEARs, BTCLEARs, ITLB misses, and ICache misses.",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.FRONTEND_LATENCY",
        "SampleAfterValue": "1000003",
        "UMask": "0x72",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to itlb miss",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.ITLB_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend that do not categorize into any other common frontend stall",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.OTHER",
        "SampleAfterValue": "1000003",
        "UMask": "0x80",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of issue slots every cycle that were not delivered by the frontend due to predecode wrong",
        "EventCode": "0x71",
        "EventName": "TOPDOWN_FE_BOUND.PREDECODE",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Fixed Counter: Counts the number of consumed retirement slots.  Similar to UOPS_RETIRED.ALL",
        "EventName": "TOPDOWN_RETIRING.ALL",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x7",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of consumed retirement slots.  Similar to UOPS_RETIRED.ALL",
        "EventCode": "0x72",
        "EventName": "TOPDOWN_RETIRING.ALL_NON_ARCH",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of consumed retirement slots.  Similar to UOPS_RETIRED.ALL",
        "EventCode": "0xc2",
        "EventName": "TOPDOWN_RETIRING.ALL_P",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Number of non dec-by-all uops decoded by decoder",
        "EventCode": "0x76",
        "EventName": "UOPS_DECODED.DEC0_UOPS",
        "PublicDescription": "This event counts the number of not dec-by-all uops decoded by decoder 0.",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Uops executed on INT EU ALU ports.",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.ALU",
        "PublicDescription": "Number of ALU integer uops dispatch to execution.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Uops executed on any INT EU ports 0 thorugh 5",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.INT_EU_ALL",
        "PublicDescription": "Number of integer uops dispatched to execution.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of Uops dispatched/executed by any of the 3 JEUs (all ups that hold the JEU including macro; micro jumps; fetch-from-eip)",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.JMP",
        "PublicDescription": "Number of jump uops dispatch to execution",
        "SampleAfterValue": "2000003",
        "UMask": "0x40",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Uops executed on Load ports 2, 3 and 12",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.LOAD",
        "PublicDescription": "Number of Load uops dispatched to execution.",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of (shift) 1-cycle Uops dispatched/executed by any of the Shift Eus",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.SHIFT",
        "PublicDescription": "Number of SHIFT integer uops dispatch to execution",
        "SampleAfterValue": "2000003",
        "UMask": "0x20",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of Uops dispatched/executed by Slow EU (e.g. 3+ cycles LEA, >1 cycles shift, iDIVs, CR; *H operation)",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.SLOW",
        "PublicDescription": "Number of Slow integer uops dispatch to execution.",
        "SampleAfterValue": "2000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Number of Uops dispatched on port 7; 8 and 13 (STA)",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.STA",
        "PublicDescription": "Number of STA (Store Address) uops dispatch to execution",
        "SampleAfterValue": "2000003",
        "UMask": "0x80",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Uops executed on STD ports 4 and 9",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.STD",
        "PublicDescription": "Number of STD (Store Data) uops dispatch to execution",
        "SampleAfterValue": "2000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles where at least 1 uop was executed per-thread",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_1",
        "PublicDescription": "Cycles where at least 1 uop was executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles where at least 2 uops were executed per-thread",
        "CounterMask": "2",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_2",
        "PublicDescription": "Cycles where at least 2 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles where at least 3 uops were executed per-thread",
        "CounterMask": "3",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_3",
        "PublicDescription": "Cycles where at least 3 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles where at least 4 uops were executed per-thread",
        "CounterMask": "4",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_4",
        "PublicDescription": "Cycles where at least 4 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts number of cycles no uops were dispatched to be executed on this thread.",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.STALLS",
        "Invert": "1",
        "PublicDescription": "Counts cycles during which no uops were dispatched from the Reservation Station (RS) per thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of uops to be executed per-thread each cycle.",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.THREAD",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of x87 uops dispatched.",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.X87",
        "PublicDescription": "Counts the number of x87 uops executed.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Uops that RAT issues to RS",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.ANY",
        "PublicDescription": "Counts the number of uops that the Resource Allocation Table (RAT) issues to the Reservation Station (RS).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "UOPS_ISSUED.CYCLES",
        "CounterMask": "1",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.CYCLES",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of load uops that got allocated and converted to LDCHECK.",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.MRN_LDCHECK",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles when RAT does not issue Uops to RS for the thread",
        "CounterMask": "1",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.STALLS",
        "Invert": "1",
        "PublicDescription": "Counts cycles during which the Resource Allocation Table (RAT) does not issue any Uops to the reservation station (RS) for the current thread.",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of uops retired",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.ALL",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Cycles with retired uop(s).",
        "CounterMask": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.CYCLES",
        "PublicDescription": "Counts cycles where at least one uop has retired.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of frontend-tagged retired micro-operations (uops) except the last uop of each instruction. An instruction that is decoded into less than two uops does not contribute to the count.",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.FRONTEND",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Retired uops except the last uop of each instruction.",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.HEAVY",
        "PublicDescription": "Counts the number of retired micro-operations (uops) except the last uop of each instruction. An instruction that is decoded into less than two uops does not contribute to the count.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of integer divide uops retired",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.IDIV",
        "PEBS": "1",
        "SampleAfterValue": "2000003",
        "UMask": "0x10",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of uops retired that were delivered by the loop stream detector (LSD).",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.LSD",
        "PEBS": "1",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "UOPS_RETIRED.MS",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.MS",
        "MSRIndex": "0x3F7",
        "MSRValue": "0x8",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of uops that are from the complex flows issued by the micro-sequencer (MS).  This includes uops from flows due to complex instructions, faults, assists, and inserted flows.",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.MS",
        "PEBS": "1",
        "SampleAfterValue": "2000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Number of non-speculative switches to the Microcode Sequencer (MS)",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.MS_SWITCHES",
        "MSRIndex": "0x3F7",
        "MSRValue": "0x8",
        "PublicDescription": "Switches to the Microcode Sequencer",
        "SampleAfterValue": "2000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "This event counts a subset of the Topdown Slots event that are utilized by operations that eventually get retired (committed) by the processor pipeline. Usually, this event positively correlates with higher performance  for example, as measured by the instructions-per-cycle metric.",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.SLOTS",
        "PublicDescription": "This event counts a subset of the Topdown Slots event that are utilized by operations that eventually get retired (committed) by the processor pipeline. Usually, this event positively correlates with higher performance  for example, as measured by the instructions-per-cycle metric.\nSoftware can use this event as the numerator for the Retiring metric (or top-level category) of the Top-down Microarchitecture Analysis method.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles without actually retired uops.",
        "CounterMask": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.STALLS",
        "Invert": "1",
        "PublicDescription": "This event counts cycles without actually retired uops.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Cycles no executable uops retired",
        "CounterMask": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.STALL_PERIODS",
        "Invert": "1",
        "PublicDescription": "This is a non-precise version (that is, does not use PEBS) of the event that counts cycles without actually retired uops.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts the number of x87 uops retired, includes those in ms flows",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.X87",
        "PEBS": "1",
        "SampleAfterValue": "2000003",
        "UMask": "0x20",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of uops retired with an approximate 2x throughput difference between Core and Atom",
        "EventCode": "0x7c",
        "EventName": "UOPS_RETIRED_OPTYPE.2X",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of uops retired with a 4x or greater throughput difference between Core and Atom",
        "EventCode": "0x7c",
        "EventName": "UOPS_RETIRED_OPTYPE.4X",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of FP long latency uops retired including FMA, FMUL, and FADD",
        "EventCode": "0x7c",
        "EventName": "UOPS_RETIRED_OPTYPE.FPLL",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts the number of simul uops retired",
        "EventCode": "0x7c",
        "EventName": "UOPS_RETIRED_OPTYPE.SIMUL",
        "PEBS": "1",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_core"
    },
    {
        "BriefDescription": "Counts number of vector uops dispatched on VEC0",
        "EventCode": "0xb4",
        "EventName": "VEC_DISPATCHED.V0",
        "SampleAfterValue": "1000003",
        "UMask": "0x1",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts number of vector uops dispatched on VEC0",
        "EventCode": "0xb4",
        "EventName": "VEC_DISPATCHED.V1",
        "SampleAfterValue": "1000003",
        "UMask": "0x2",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts number of vector uops dispatched on VEC0",
        "EventCode": "0xb4",
        "EventName": "VEC_DISPATCHED.V2",
        "SampleAfterValue": "1000003",
        "UMask": "0x4",
        "Unit": "cpu_atom"
    },
    {
        "BriefDescription": "Counts number of vector uops dispatched on VEC0",
        "EventCode": "0xb4",
        "EventName": "VEC_DISPATCHED.V3",
        "SampleAfterValue": "1000003",
        "UMask": "0x8",
        "Unit": "cpu_atom"
    }
]
